# 5장 any 다루기

## 아이템 38 any 타입은 가능한 좁은 범위에서만 사용하기

- 의도치 않은 타입 안전성의 손실을 피하기 위해서 any의 사용 범위를 최소한으로 좁혀야한다.
- 함수의 반환 타입이 any인 경우 타입 안정성이 나빠진다. 따라서 any 타입을 반환하면 절대 안된다.
- 강제로 타입 오류를 제거하려면 any 대신 @tds-ignore 사용하는것이 좋다.

## 아이템 39 any를 구체적으로 변형해서 사용하기

- any를 사용할 때는 정말로 모든 값이 허용되어야만 하는지 면밀히 검토해야 한다.
- any보다 더 정확하게 모델링할 수 있도록 any[] 또는 {id : [string] : any} 또는 () => any처럼 구체적인 형태가 사용되어야한다.

## 아이템 40 함수 안으로 타입 단언문 감추기

- 타입 선언문은 일반적으로 타입을 위험하게 만들지만 상황에 따라 필요하기도 하고 현실적인 해결책이 되기도 한다. 불가피하게 사용해야 한다면, 정확한 정의를 가지는 함수 안으로 숨키도록 한다.

## 아이템 41 any의 진화를 이해하기

- 일반적인 타입들은 정제되기만 하는 반면, 암시적 any와 any[] 타입은 진화할 수 있다. 이러한 동작이 발생하는 코드를 인지하고 이해할 수 있어야한다.
- any를 진화시키는 방식보다 명시적 타입 구문을 사용하는 것이 안전한 타입을 유지하는 방법이다.

## 아이템 42 모르는 타입의 값에는 any 대신 unknown을 사용하기

- unknown은 any 대신 사용할 수 있는 안전한 타입이다. 어떠한 값이 있지만 그 타입을 알지 못하는 경우라면 unknown을 사용하면 된다.
- 사용자가 타입 단언문이나 타입 체크를 사용하도록 강제하려면 unknown을 사용하면 된다.
- {}, object, unknown의 차이점을 이해해야한다.

## 아이템 43 몽키 패치보다는 안전한 타입을 사용하기

- 전역 변수나 DOM에 데이터를 저자와지 말고, 데이터를 분리하여 사용해야 한다.
- 내장 타입에 데이터를 저장해야 하는 경우, 안전한 타입 접근법 중 하나(보강이나 사용자 정의 인터페이스로 단언)을 사용해야 한다.
- 보강의 모듈 영역 문제를 이해해야 한다.

## 아이템 44 타입 커버리지를 추적하여 타입 안전성 유지하기

- noImplictAny가 설정되어 있어도, 명시적 any 또는 서드파티 타입 선언을 통해 any 타입은 코드 내에 여전히 존재할 수 있다는 점을 주의 해야 한다.
- 작성한 프로그램의 타입이 얼마나 잘 선언되어있는지 추적해야 한다. 추적함으로서 any의 사용을 줄여 나갈 수 있고 타입 안전성을 꾸준히 높일 수 있다.
