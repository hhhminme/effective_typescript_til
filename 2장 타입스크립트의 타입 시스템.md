# 2장 타입스크립트의 타입 시스템

## 아이템6 - 편집기를 사용하여 타입 시스템 탐색하기

- 편집기에서 타입스크립트 언어 서비스를 적극적으로 활용해야 한다.
- 편집기를 사용하면 어떻게 타입 시스템이 동작하는지, 그리고 타입스크립트가 어떻게 타입을 추론하는지 개념을 잡을 수 있다.
- 타입스크립트가 동작을 어떻게 모델링하는지 알 기 위해 타입 선언 파일을 찾아보는 방법을 터득해야한다.

## 아이템7 - 타입이 값들의 집합이라고 생각하기

- 타입을 값의 집합으로 생각하면 이해하기 편하다. 이 집합은 유한하거나 무한하다.
- 타입스크립트 타입은 엄격한 상속 관계가 아니라 겹쳐지는 집합으로 표현된다. 두 타입은 서로 서브타입이 아니면서도 겹쳐질 수 있다.
- 한 객체의 추가적인 속성이 타입 선언에 언급되지 않더라도 그 타입에 속할 수 있다.
- 타입 연산은 집합의 범위에 적용된다. a와 b의 인터섹션은 a의 범위와 b의 범위의 인터섹션이다. 객체 타입에서는 A & B 인 값이 A와 B의 속성을 모두 가짐을 이해한다.
- a는 b를 상속, a는 b에 할당 가능, a는 b의 서브 타입은 모두 a는 b의 부분집합과 같은 의미이다.

(어려웠던 챕터)

## 아이템8 - 타입 공간과 값 공간의 심벌 구분하기

- 타입스크립트 코드를 읽을 때 타입인지 값인지 구분하는 방법을 터특해야 한다. 타입스크립트 플레이그라운드를 활용해 개념을 잡는 것이 좋다.
- 모든 값은 타입을 가지지만 타입은 값을 가지지 않는다. type과 interface같은 키워드는 타입 공간에만 존재한다.
- class나 enum같은 키워드는 타입과 값 두 가지로 사용될 수 있다.
- "foo"는 문자열 리터럴이거나, 문자열 리터럴 타입일 수 있다. 차이점을 알고 구별하는 방법을 터특해야한다.
- typeof, this 그리고 많은 다른 연산자들과 키워드들은 타입 공간과 값 공간에서 다른 목적으로 사용될 수 있다.

## 아이템9 - 타입 단언보다는 타입 선언을 사용하기

- 타입 단언`as Type`보다 타입 선언`:Type`을 사용해야한다.
- 화살표 함수의 반환 타입을 명시하는 방법을 터특해야 한다.
- 타입 스크립트보다 타입 정보를 더 잘 알고 있는 상황(DOM element)에서는 타입 단언문과 null 아님 단언문을 사용하면 된다.

## 아이템10 - 객체 래퍼 타입 피하기

- 기본형 값에 메서드를 제공하기 위해 객체 래퍼 타입이 어떻게 쓰이는지 이해해야 한다. 직접 사용하거나 인스턴스를 생성하는 것은 피해야한다.
- 타입스크립트 객체 래퍼 타입은 지양하고, 대신 기본형 타입을 사용해야 한다.
- String 대신 string, Number 대신 number, Boolean 대신 boolean, Symbol대신 symbol, BigInt 대신 bigint를 사용해야한다.

## 아이템 11 - 잉여 속성 체크의 한계 인지하기

- 객체 리터럴을 변수에 할당하거나 함수에 매개변수로 전달할 때 잉여 속성 체크가 수행된다
- 잉여 속성 체크는 오률를 찾는 효과적인 방법이지만, 타입스크립트 타입체커가 수행하는 일반적인 구조적 할당 가능성 체크와 역할이다르다. 할당의 개념을 정확히 알아야 잉여 속성 체크와 일반적인 구조적 할당 가능성 체크를 구분할 수 있다.
- 잉여 속성 체크에는 한계가 있다. 임시 변수를 도입하면 잉여 속성 체크를 건너뛸 수 있다.

## 아이템 12 - 함수 표현식에 타입 적용하기

- 매개변수나 반환 값에 타입을 명시하기 보다는 함수 표현식 전체에 타입 구문을 적용하는 것이다 좋다.
- 만약 같은 타입 시그니처를 반복적으로 작성한 코드가 있다면 함수 타입을 분리해 내거나 이미 존재하는 타입을 찾아보도록 한다. 라이브러리를 직접 만든다면 공통 콜백에 타입을 제공해야한다.
- 다른 함수의 시그니처를 참조하려면 typeof fn을 사용해야한다.

## 아이템 13 - 타입과 인터페이스 차이점 알기

- 타입과 인터페이스의 차이점과 비슷한 점을 이해해야한다.
- 한 타입을 type과 interface 두 가지 문법을 사용해서 작성하는 방법을 터특해야 한다
- 프로젝트에서 어떤 문법을 사용항지 결정할 때 한 가지 일관도니 스타일을 확립하고, 보강 기법이 필요한지 고려해야 한다.

## 아이템 14 - 타입 연산과 제너릭 사용으로 반복 줄이기

- DRY(Don't Repeat yourself) 원칙을 타입에도 최대한 적용해야 한다.
- 타입에 이름을 붙여서 반복을 피해햐 한다. extends 를 사용해서 인터페이스 필드의 반복을 피해야한다.
- 타입들 간의 매핑을 위해 타입스크립트가 제공하는 도구들을 공부하면 좋다. 여기에는 keyof, typeof, 인덱싱, 매핑된 타입들이 포함된다.
- 제너릭 타입을 타입을 위한 함수와 같다. 타입을 반복ㅂ하는 대신 제너릭 타입을 사용하여 타입들 간에 매플을 하는 것이 좋다. 제너릭 타입을 제한하려면 extends를 사용하면 된다.
- 표준 라이브러리에 정의된 Pick, Partial, ReturnType같은 제너릭 타입에 익숙해져야한다.

(어려움)

## 아이템 15 - 동적 데이터에 인덱스 시그니처 사용하기

- 런타임 때까지 객체의 속성을 알 수 없을 경우에만 (예를 들어 CSV 파일에서 로드하는 경우) 인덱스 시그니처를 사용하도록 한다.
- 안전한 접근을 위해 인덱스 시그니처의 값 타입에 undefined를 추가하는 것도 고려하여야한다.
- 가능하면 인터페이스, Record, 매핑된 타입 같은 인덱스 시그니처보다 정확한 타입을 사용하는 것이 좋다.

## 아이템 16 - number 인덱스 시그니처보다 Array, 튜플, ArrayLike 사용하기

- 배열은 객체이므로 키는 숫자가 아니라 문자열이다. 인덱스 시그니처로 사용된 number 타입은 버그를 잡기 위한 순수 타입스크립트 코드이다. 인덱스 시그니처에 number를 사용하기 보다 Array나 튜플, 또는 ArrayLike 타입을 사용하는 것이 좋다.

## 아이템 17 변경 관련된 오류 방지를 위해 readonly 사용하기

- 만약 함수가 매개변수를 수정하지 않는다면 readonly로 선언하는 것이 좋다. readonly 매개변수는 인터페이스를 명확하게 하며, 매개변수가 변경되는 것을 방지한다.
- readonly를 사용하면 변경하면서 발생하는 오류를 방지할 수 있고, 변경이 발생하는 코드도 쉽게 찾을 수 있다.
- const 와 readonly의 차이에 이해해야한다.
- readonly는 얕게 동작하는다는 것을 명심해야한다.

  ## 아이템 18 - 매핑된 타입을 사용하여 값을 동기화하기

  - 매팽된 타입을 사용해서 관련된 값과 타입을 동기화하도록 한다
  - 인터페이스에 새로운 속성을 추가할 때, 선택을 강제하도록 매핑된 타입을 고려해야 한다.
